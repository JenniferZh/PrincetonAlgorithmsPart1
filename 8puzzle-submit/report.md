## 序
8 puzzle是一个大家都玩过的游戏，3*3个格子里面有8个方块，上面的图画拼起来是一个大图片，有一个空位置可以供这些方块移动，便产生了一些问题：给定一个初始状态，可以通过移动恢复成有序的样子吗？如果可以，最少几次移动呢？

## 方案选择
我们可以使用**bfs**进行搜索，每个节点是一个棋盘状态。但其实我们可以使用更高级的bfs来让搜索变的更快——**A star search**.

这个搜索方法的关键是：把bfs中的队列换成优先队列，先弹出最接近结果的。最接近结果的考评方法，我们需要设置合适的考评函数，例如在8 puzzle问题中，有几个方块已经在他们应该在的位置上就是考评这个状态是否接近最终结果的方案之一。

一个介绍本算法的视频：https://www.youtube.com/watch?v=ySN5Wnu88nE

## 在写作业是遇到的问题

### Board类中equals()的实现
记住以下套路：
- 判断x是不是同一个指针x == this
- 判断x是不是null
- 判断x的**class**是不是本类型，如果是才可以强制转化
- 强制转化类型，写你想写的比较逻辑
```
public boolean equals(Object x) {
    if (x == this) return true;
    if (x == null) return false;
    if (x.getClass() != this.getClass()) return false;
    
    Board other = (Board) x;
    // start comparison...
}
```

### 如何发现当前状态有解呢？

当我们设置一个优先队列来储存状态，如果初始状态本来就没有解，那将为陷入一个死循环，因此我们首先应该判断是否有解。

判断有解的方案：作业提示中讲了一个定理，对于任何一个初始状态，我们可以找到另一个状态（方法是交换原有状态的**任意**两个方格[不包含空方格]的位置）这两个状态中，如果一个可以达到终点，那另一个肯定不行。

基于以上原理，我们可以理解为什么Board类中让我们实现一个twin函数，这个函数就是生成上述的**另一个状态**的。

因此，我们在初始化时，可以**把初始状态，和初始状态的一个twin状态都放入优先队列**，这样，一定有一个可以到达目标状态，所以循环一定可以结束；在达到目标状态时，只需要判断是twin状态的子节点还是初始状态的子节点就可以确定，是否可解，以及最短路径长度。

### 重复状态的避免

我们希望避免的情况是，一个格子推过去后，在下一个状态又被推回来了。因此，进入队列时，我们可以预先检查即将入队列的状态是否和当前状态的**父状态重复**（就是不要让爷爷和孙子重复）

### 注意immutable
课堂上说，放在priority queue里面的类中与大小比较有关的变量推荐设置为immutable的——即**final类型**。顺便，在practice中，如果你没有一个一定要修改这个变量的理由，那么记得一定声明这个变量为final的，这是一个好习惯。

## 结果
本次作业获得93分，correctness用例全部通过，扣分在时间效率上。